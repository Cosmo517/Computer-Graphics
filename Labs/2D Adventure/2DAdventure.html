<html lang="en">
    <HEAD>
        <meta charset="UTF-8">
        <title>2D Adventure</title>
        <style>
            html, body {
                margin: 0 !important;
                padding: 0 !important;
            }
        </style>
    </HEAD>
    <body>
		<CANVAS id="myCanvas" width="896" height="512">
			Your browser does not support canvas.
		</CANVAS>
        <script>
            class Main {
                constructor(ctx) {
                    this.ctx = ctx;
                    this.player = new Player(10, 10, 5, 3, -1, -1, "./src/Player.png");
                    this.enemies = [];
                    // 0 is free, 1 is wall, 2 is tree
                    // 3 is potion, 4 is player, 5 is monster
                    this.obstacles = [];
                    this.potions = [];
                    this.canvasWidth = 896;
                    this.canvasHeight = 512;

                    for (let i = 0; i < this.canvasHeight / 64; i++) {
                        const row = [];
                        for (let j = 0; j < this.canvasWidth / 64; j++) {
                            row.push(0);
                        }
                        this.obstacles.push(row)
                    }

                    // Start by drawing the map (walls/trees)
                    this.drawMap();

                    // Then add potions
                    this.addPotionToMap();
                    this.addPotionToMap();

                    // Add the player
                    let randomX = 0;
                    let randomY = 0;
                    do {
                        randomX = Math.floor(Math.random() * (this.canvasWidth / 64));
                        randomY = Math.floor(Math.random() * (this.canvasHeight / 64));
                    } while (this.obstacles[randomY][randomX] != 0);

                    this.player.render(randomX, randomY, this.ctx);
                    this.obstacles[randomY][randomX] == 4;
                    
                    // Add the monsters
                }

                drawBrick(xStart, yStart) {
                    this.ctx.beginPath();

                    // Top line
                    this.ctx.moveTo(xStart, yStart);
                    this.ctx.lineTo(xStart + 64, yStart);

                    // Left side vertical
                    this.ctx.moveTo(xStart, yStart);
                    this.ctx.lineTo(xStart, yStart + 64);

                    // Right side vertical
                    this.ctx.moveTo(xStart + 64, yStart);
                    this.ctx.lineTo(xStart + 64, yStart + 64);

                    // Bottom horizontal
                    this.ctx.moveTo(xStart, yStart + 64);
                    this.ctx.lineTo(xStart + 64, yStart + 64);

                    let newYStart = yStart
                    for (let i = 0; i < 3; i++) {
                        // Vert lines down 13 units
                        this.ctx.moveTo(xStart + 8, newYStart);
                        this.ctx.lineTo(xStart + 8, newYStart + 13);
                        this.ctx.moveTo(xStart + 32, newYStart);
                        this.ctx.lineTo(xStart + 32, newYStart + 13)
                        this.ctx.moveTo(xStart + 56, newYStart);
                        this.ctx.lineTo(xStart + 56, newYStart + 13);

                        // 2nd line horizontal 
                        if (i != 2) {
                            this.ctx.moveTo(xStart, newYStart + 13);
                            this.ctx.lineTo(xStart + 64, newYStart + 13);
                        } else { 
                            break;
                        }

                        newYStart += 13;

                        // Vert lines down 13 units
                        this.ctx.moveTo(xStart + 16, newYStart);
                        this.ctx.lineTo(xStart + 16, newYStart + 13);
                        this.ctx.moveTo(xStart + 48, newYStart);
                        this.ctx.lineTo(xStart + 48, newYStart + 13)

                        // 2nd line horizontal
                        this.ctx.moveTo(xStart, newYStart + 13);
                        this.ctx.lineTo(xStart + 64, newYStart + 13);

                        newYStart += 13;
                    }
                    
                    this.ctx.stroke();
                }

                drawTree(xStart, yStart) {
                    this.ctx.beginPath();
                    
                    this.ctx.strokeStyle = "black";
                    this.ctx.fillStyle = "brown";
                    this.ctx.fillRect(xStart + 24, yStart + 24, 16, 40);
                    this.ctx.stroke();

                    this.ctx.strokeStyle = "black";
                    this.ctx.fillStyle = "green"
                    this.ctx.arc(xStart + 32 , yStart + 24, 24, 0, Math.PI * 2, 1);
                    this.ctx.fill();

                    this.ctx.stroke();
                }

                drawMap() {
                    // Draw brick border
                    for (let y = 0; y < this.canvasHeight / 64; y++) {
                        for (let x = 0; x < this.canvasWidth / 64; x++) {
                            if (y == 0 || y == (this.canvasHeight / 64) - 1) {
                                this.drawBrick(x * 64, y * 64);
                                this.obstacles[y][x] = 1;
                            }

                            if ((y != 0 && y != (this.canvasHeight / 64) - 1) && (x == 0 || x == (this.canvasWidth / 64) - 1)) {
                                this.drawBrick(x * 64, y * 64);
                                this.obstacles[y][x] = 1;
                            }
                        }
                    }

                    // Draw Trees
                    const totalTrees = 15;
                    let currentTrees = 0;

                    while (currentTrees < totalTrees) {
                        const xTest = Math.floor(Math.random() * (this.canvasWidth / 64));
                        const yTest = Math.floor(Math.random() * (this.canvasHeight / 64));

                        if (!this.obstacles[yTest][xTest]) {
                            this.drawTree(xTest * 64, yTest * 64);
                            this.obstacles[yTest][xTest] = 2
                            currentTrees++;
                        }
                    }

                    // Grab a random location that is traversable
                    let xTest = 0;
                    let yTest = 0;
                    do {
                        xTest = Math.floor(Math.random() * (this.canvasWidth / 64));
                        yTest = Math.floor(Math.random() * (this.canvasHeight / 64));
                    } while (this.obstacles[yTest][xTest] != 0)

                    // If we cannot traverse to every square, regenerate the map
                    if (this.checkUnreachableSpots(structuredClone(this.obstacles), xTest, yTest, 0)) {
                        console.log("Found unreachable spot... Redrawing map");
                        for (let i = 0; i < this.canvasHeight / 64; i++) {
                            for (let j = 0; j < this.canvasWidth / 64; j++) {
                                if (this.obstacles[i][j] == 2) {
                                    this.obstacles[i][j] = 0;
                                }
                            }
                        }
                        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                        this.drawMap();
                    }
                }

                checkUnreachableSpots(obstacles, x, y, depth) {
                    obstacles[y][x] = 10;

                    // + 1 is going down for y axis
                    if (obstacles[y + 1][x] == 0) {
                        this.checkUnreachableSpots(obstacles, x, y + 1, depth + 1);
                    }
                    if (obstacles[y - 1][x] == 0) {
                        this.checkUnreachableSpots(obstacles, x, y - 1, depth + 1);
                    }
                    if (obstacles[y][x + 1] == 0) {
                        this.checkUnreachableSpots(obstacles, x + 1, y, depth + 1);
                    }
                    if (obstacles[y][x - 1] == 0) {
                        this.checkUnreachableSpots(obstacles, x - 1, y, depth + 1);
                    }

                    // Check if there is an unreachable spot... if there is
                    // return true, otherwise false
                    if (depth == 0) {
                        for (let i = 0; i < this.canvasHeight / 64; i++) {
                            for (let j = 0; j < this.canvasWidth / 64; j++) {
                                if (obstacles[i][j] == 0) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                }

                addPotionToMap() {
                    const choosePotion = Math.floor(Math.random() * 2);
                    let potion = null;

                    let randomX = 0;
                    let randomY = 0;

                    do {
                        randomX = Math.floor(Math.random() * (this.canvasWidth / 64));
                        randomY = Math.floor(Math.random() * (this.canvasHeight / 64));
                    } while (this.obstacles[randomY][randomX] != 0);

                    // 1 is health potion, 0 is regen potion
                    if (choosePotion) {
                        console.log("Spawning Health Potion at: (" + randomX + ", " + randomY + ")")
                        const potionImg = new Image();
                        potionImg.onload = () => {
                            this.ctx.drawImage(potionImg, randomX * 64, randomY * 64, 64, 64);
                        };
                        potionImg.src = "./src/HealthPotion.png";
                        potion = new HealthPotion("Health Potion", randomX, randomY, potionImg, 5);
                        this.obstacles[randomY][randomX] = 3;
                    } else {
                        console.log("Spawning Regen Potion at: (" + randomX + ", " + randomY + ")")
                        const potionImg = new Image();
                        potionImg.onload = () => {
                            this.ctx.drawImage(potionImg, randomX * 64, randomY * 64, 64, 64);
                        };
                        potionImg.src = "./src/RegenPotion.png";
                        potion = new RegenPotion("Regen Potion", randomX, randomY, "", 2, 5);
                        this.obstacles[randomY][randomX] = 3;
                    }
                }

                update(key) {
                    if (key == "w") {
                        const charX = this.player.x;
                        const charY = this.player.y;
                        if (!this.obstacles[charY - 1][charX] || this.obstacles[charY - 1][charX] == 3) {
                            this.obstacles[charY][charX] = 0;
                            this.obstacles[charY - 1][charX] = 4;
                            this.player.render(charX, charY - 1, this.ctx);
                        }
                    } else if (key == "a") {
                        const charX = this.player.x;
                        const charY = this.player.y;
                        if (!this.obstacles[charY][charX - 1] || this.obstacles[charY][charX - 1] == 3) {
                            this.obstacles[charY][charX] = 0;
                            this.obstacles[charY][charX - 1] = 4;
                            this.player.render(charX - 1, charY, this.ctx);
                        }
                    } else if (key == "s") {
                        const charX = this.player.x;
                        const charY = this.player.y;
                        if (!this.obstacles[charY + 1][charX] || this.obstacles[charY + 1][charX] == 3) {
                            this.obstacles[charY][charX] = 0;
                            this.obstacles[charY + 1][charX] = 4;
                            this.player.render(charX, charY + 1, this.ctx);
                        }
                    } else if (key == "d") {
                        const charX = this.player.x;
                        const charY = this.player.y;
                        if (!this.obstacles[charY][charX + 1] || this.obstacles[charY][charX + 1] == 3) {
                            this.obstacles[charY][charX] = 0;
                            this.obstacles[charY][charX + 1] = 4;
                            this.player.render(charX + 1, charY, this.ctx);
                        }
                    }
                }
            }

            class Character {
                constructor(hp, mhp, atk, def, x, y, image) {
                    this.hp = hp;
                    this.mhp = mhp;
                    this.atk = atk;
                    this.def = def;
                    this.x = x;
                    this.y = y;
                    this.image = image;
                }

                damage(enemy) {
                    this.hp -= Math.max(enemy.atk - this.def, 1) * (Math.floor(Math.random() * 6) + 1);
                }

                // Figure out how to render and place the character...
                render(newX, newY, ctx) {
                    // Render the character at the new X/Y and clear the old player
                    ctx.clearRect(this.x * 64, this.y * 64, 64, 64);

                    const characterImg = new Image();
                    characterImg.onload = () => {
                        ctx.drawImage(characterImg, newX * 64, newY * 64, 64, 64);
                    };
                    characterImg.src = this.image;

                    this.x = newX;
                    this.y = newY;
                }
            }

            class Player extends Character {
                constructor(hp, mhp, atk, def, x, y, image) {
                    super(hp, mhp, atk, def, x, y, image);
                }
            }

            class Monster extends Character {
                constructor(hp, mhp, atk, def, x, y, image) {
                    super(hp, mhp, atk, def, x, y, image);
                }
            }

            class Potion {
                constructor(name, x, y, image) {
                    this.name = name;
                    this.x = x;
                    this.y = y;
                    this.image = image;
                }

                usePotion() {
                    // Throw an error here, as you cant use a
                    // potion that does not have an effect
                }
            }

            class HealthPotion extends Potion {
                constructor(name, x, y, image, healAmount) {
                    super(name, x, y, image);
                    this.healAmount = healAmount;
                }

                usePotion() {
                    // Implement health potion here
                    // either +5 hp or 25% of HP, whatever is greater
                }
            }

            class RegenPotion extends Potion {
                constructor(name, x, y, image, hps, duration) {
                    super(name, x, y, image);
                    this.hps = hps;
                    this.duration = duration;
                }

                usePotion() {
                    // Implement health potion here
                    // either +5 hp or 25% of HP, whatever is greater
                }
            }

            const canvas = document.getElementById("myCanvas");

            canvas.width = 896;
            canvas.height = 512;

            const ctx = canvas.getContext("2d");   

            const game = new Main(ctx);

            document.addEventListener('keydown', (event) => {
                game.update(event.key);
            });
        </script>
    </body>
</html>