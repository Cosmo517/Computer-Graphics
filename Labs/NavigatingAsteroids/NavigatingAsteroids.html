<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
        <Title>"Navigating Asteroids"</TITLE>
        
        <link rel="stylesheet" href="styles.css">

		<script id="2dVertexShader" type="notjs">
            attribute vec4 a_position;	
            //We now want to read in Colors
            attribute vec3 vert_color;
            //However, we want to send the color to
            //The fragment Shader
            varying vec3 fragColor;		
            uniform vec3 transform;
            uniform vec3 rotation;		
            
            uniform vec3 worldLoc;
            uniform vec3 worldRotation;
            uniform float n;
            uniform float f;
            uniform float r;
            uniform float t;
            
            vec4 MoveCamera(vec4 pos) {
                vec3 cw = cos(worldRotation);
                vec3 sw = sin(worldRotation);
                mat4 translateView = mat4(1.0, 0.0, 0.0, 0.0,
                                            0.0, 1.0, 0.0, 0.0,
                                            0.0, 0.0, 1.0, 0.0,
                            -1.0 * worldLoc.x, -1.0 * worldLoc.y, worldLoc.z, 1.0
                );
                
                mat4 rotateView = mat4(cw.y, 0.0, -1.0 * sw.y, 0.0,
                                            0.0, 1.0, 0.0, 0.0,
                                            sw.y, 0.0, cw.y, 0.0,
                                            0.0, 0.0, 0.0, 1.0
                );
                
                return translateView * rotateView * pos;
            }
            
            vec4 ApplyProjection(vec4 pos) {
                mat4 SimpleOrtho = mat4(1.0, 0.0, 0.0, 0.0,
                                        0.0, 1.0, 0.0, 0.0,
                                        0.0, 0.0, 1.0, 0.0,
                                        0.0, 0.0, 0.0, 1.0
                );
                
                mat4 ComplexPerspective = mat4(
                                                n / r, 0.0, 0.0, 0.0,
                                                0.0, n / t, 0.0, 0.0,
                                                0.0, 0.0, -1.0 * (f + n) / (f - n), -1.0,
                                                0.0, 0.0, -2.0 * f * n / (f - n), 0.0
                );
                
                mat4 ComplexOrtho = mat4(
                                        1.0 / r, 0.0, 0.0, 0.0,
                                        0.0, 1.0 / t, 0.0, 0.0,
                                        0.0, 0.0, 1.0, 0.0,
                                        0.0, 0.0, 0.0, 1.0
                );
                
                mat4 SimplePerspective = mat4(
                                                1.0, 0.0, 0.0, 0.0,
                                                0.0, 1.0, 0.0, 0.0,
                                                0.0, 0.0, -1.0, -1.0,
                                                0.0, 0.0, -2.0, 0.0
                );
                
                // Doesnt have to be SimplePerspective, it can be one of the ones above as well
                return SimplePerspective * pos;
            }
            
            vec4 PositionObject(vec4 pos)
            {
                mat4 translateM = mat4(1.0,0.0,0.0,0.0,
                                        0.0,1.0,0.0,0.0,
                                        0.0,0.0,1.0,0.0,
                                        transform.x,transform.y,transform.z,1.0
                );
                return translateM*pos;	
            }
            
            //Use a function to Rotate the object
            vec4 RotateObject(vec4 pos)
            {
                //This is a nice trick
                vec3 c = cos(rotation);
                vec3 s = sin(rotation);
                fragColor = vert_color;
                //Surprise!  we have to go column firt when we enter the matrix.

                //mat4 rotateX = mat4();
                mat4 rotateY = mat4(c.y,0.0,-1.0*s.y,0.0,
                                    0.0,1.0,0.0,0.0,
                                    s.y,0.0,c.y,0.0,
                                    0.0,0.0,0.0,1.0);
                                    
                mat4 rotateZ = mat4(c.z,s.z,0.0,0.0,
                                    -1.0*s.z,c.z,0.0,0.0,
                                    0.0,0.0,1.0,0.0,
                                    0.0,0.0,0.0,1.0);
                return rotateY*rotateZ*pos;
            }
            
            void main()
            {
                fragColor = vert_color;
                vec4 worldCord = PositionObject(RotateObject(a_position));
                vec4 cameraSpace = MoveCamera(worldCord);
                
                gl_Position = ApplyProjection(cameraSpace);
            }		
        </script>

		<script id="2dFragmentShader" type="notjs">
            //Fragment shaders do not have precision so we have to set it.
            precision mediump float;
            varying vec3 fragColor;
            void main()
            {
                //gl_FragColor = vec4(0,0,1,1); //Between 0 and 1.
                gl_FragColor = vec4(fragColor,1);
            }
		</script>
		
        <script src="Transform.js"></script>
        <script src="GameObject.js"></script>
        <script src="Bullet.js"></script>
        <script src="Player.js"></script>
        <script src="Asteroid.js"></script>
		<script src="webgl_interface.js"></script>		
        
		<script>
            class main {	
                constructor() {
                    this.Visual = [];
                    this.Solid = [];
                    this.Trigger = [];
                    this.ObjectCounter = 0;			

                    this.myWEBGL = new WebGL_Interface();
                    this.Keys = [];

                    // This will create the player
                    this.CreateObject(1, Player, [0, 0, 0], [0, 80, 0], "Player");

                    // This will generate the 200 asteroids
                    // let numAsteroids = 200;
                    // for (let i = 0; i < numAsteroids; i++) {
                    //     let randomX = Math.floor(Math.random() * 201) - 100;
                    //     let randomY = Math.floor(Math.random() * 201) - 100;
                    //     let randomZ = Math.floor(Math.random() * 21) - 10;
                    //     this.CreateObject(1, Asteroid, [randomX, randomY, randomZ], [0, 0, 0], "Asteroid")
                    //     console.log("Spawning Asteroid " + i + " at (" + randomX + ", " + randomY + ", " + randomZ + ")")
                    // }
                    this.CreateObject(1, Asteroid, [0, 0, 0], [0, 80, 0], "Player");

                    console.log(this.Solid)
                }
                
                UpdateAll() {
                    for(var i in this.Visual) {
                        this.Visual[i].update();
                    }

                    for(var i in this.Solid) {
                        this.Solid[i].update();
                    }

                    for(var i in this.Trigger) {
                        this.Trigger[i].update();
                    }
                
                }
                
                RenderAll() {
                    for(var i in this.Visual) {
                        this.Visual[i].render(this.myWEBGL.program);
                    }

                    for(var i in this.Solid) {
                        this.Solid[i].render(this.myWEBGL.program);
                    }

                    for(var i in this.Trigger) {
                        this.Trigger[i].render(this.myWEBGL.program);
                    }
                
                }

                checkCollision(loc1, rad1, loc2, rad2) {
                    let distance = Math.sqrt(Math.pow(loc1[0] - loc2[0], 2) + Math.pow(loc1[1] - loc2[1], 2) + Math.pow(loc1[2] - loc2[2], 2));
                    return (rad1 + rad2) > distance;
                }
                
                CreateObject(type, prefab, loc, rot, name) {
                    //type 0 = visual
                    //type 1 = solid
                    //type 2 = trigger
                    var temp = new prefab; //Yes this dark sorcery will work.
                    var id = "ID"+this.ObjectCounter;
                    this.ObjectCounter ++;
                    temp.id = id;
                    temp.prefab = prefab;
                    temp.loc = loc;
                    temp.rot = rot;
                    temp.name = name;

                    switch(type) {
                        case 0:
                            this.Visual[id] = temp;
                            break;
                        case 1:
                            this.Solid[id] = temp;
                            break;
                        case 2:
                            this.Trigger[id] = temp;
                            break;
                        default:
                            break;
                    }

                    //We can return the game object to the calling function
                    //Should the user want to set custom names or properties on it.
                    return temp;
                }
                
                
                DestroyObject(id) {
                    if(id in this.Visual) {
                        delete this.Visual[id];
                    }

                    if(id in this.Solid) {
                        delete this.Solid[id];
                    }

                    if(id in this.Trigger) {
                        delete this.Trigger[id];
                    }
                }
                
                KeyDown(event) {
                    this.Keys[String.fromCharCode(event.keyCode)] = true;
                    //console.log(String.fromCharCode(event.keyCode) +" should be true - "+
                    //this.Keys[String.fromCharCode(event.keyCode)]);
                }
                
                KeyUp(event) {
                    this.Keys[String.fromCharCode(event.keyCode)] = false;
                    //console.log(String.fromCharCode(event.keyCode) +" should be false - "+
                    //this.Keys[String.fromCharCode(event.keyCode)]);
                }
                
                //Static call backs go down here
                //   |
                //  \ /
                //   v
                static keyD(event) {
                    m.KeyDown(event);
                }

                static keyU(event) {
                    m.KeyUp(event);
                }

                static MainLoop() {
                    m.UpdateAll();
                    m.RenderAll();
                    requestAnimationFrame(main.MainLoop);
                }
            }
		</script>
	</Head>
    
	<BODY style="padding: 15px;">
		<HEADER></HEADER>
		
		<CANVAS class="canvas" id="myCanvas" width="780" height="780">
			Your browser does not support canvas.
		</CANVAS>
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			var m = new main();
			window.onkeydown = main.keyD;
			window.onkeyup = main.keyU;
			requestAnimationFrame(main.MainLoop);	
		</SCRIPT>
		
		<FOOTER></FOOTER>
	</BODY>
</HTML>